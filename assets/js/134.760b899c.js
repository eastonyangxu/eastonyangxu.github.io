(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{640:function(e,r,o){"use strict";o.r(r);var t=o(4),a=Object(t.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[r("a",{attrs:{href:"https://docs.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker 官网"),r("OutboundLink")],1),e._v(" |\n"),r("a",{attrs:{href:"https://docs.docker.com/get-docker/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker 下载地址"),r("OutboundLink")],1),e._v(" |\n"),r("a",{attrs:{href:"https://docs.docker.com/get-started/overview/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker 概述"),r("OutboundLink")],1)]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Docker 介绍")]),e._v(" "),r("p",[e._v("Docker 是一个用于开发、发布和运行应用程序的开放平台。Docker 使您能够将应用程序从基础设施中分离出来，以便快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础架构。通过利用 Docker 的方法快速交付、测试和部署代码，您可以显著减少编写代码和在生产环境中运行代码之间的延迟。")])]),e._v(" "),r("h2",{attrs:{id:"docker-架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker-架构"}},[e._v("#")]),e._v(" Docker 架构")]),e._v(" "),r("p",[e._v("Docker 使用 "),r("mark",[e._v("客户端-服务器架构")]),e._v("。Docker 客户端与 Docker 守护进程进行对话，该守护进程完成了构建，运行和分发 Docker 容器的繁重工作。Docker 客户端和守护程序可以 在同一系统上运行，或者您可以将 Docker 客户端连接到远程 Docker 守护程序。Docker 客户端和守护程序在 UNIX 套接字或网络接口上使用 "),r("code",[e._v("REST API")]),e._v(" 进行通信。另一个 Docker 客户端是 Docker Compose，它使您可以处理由一组容器组成的应用程序。\n"),r("img",{attrs:{src:"/docker/architecture.svg",alt:""}})]),e._v(" "),r("h3",{attrs:{id:"the-docker-daemon"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#the-docker-daemon"}},[e._v("#")]),e._v(" The Docker daemon")]),e._v(" "),r("p",[e._v("Docker "),r("mark",[e._v("守护程序")]),e._v("（Dockerd）侦听 Docker API 请求并管理 Docker 对象，例如图像，容器，网络和卷。守护程序还可以与其他守护程序通信以管理 Docker 服务。")]),e._v(" "),r("h3",{attrs:{id:"the-docker-client"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#the-docker-client"}},[e._v("#")]),e._v(" The Docker client")]),e._v(" "),r("p",[e._v("Docker "),r("mark",[e._v("客户端")]),e._v("（Docker）是许多 Docker 用户与 Docker 交互的主要方式。当您使用诸如之类的命令时 Docker run，客户端会将这些命令发送到 Dockerd，以执行这些命令。该 Docker 命令使用 Docker API。Docker 客户端可以与多个守护程序通信。")]),e._v(" "),r("h3",{attrs:{id:"docker-registries"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker-registries"}},[e._v("#")]),e._v(" Docker registries")]),e._v(" "),r("p",[e._v("Docker "),r("mark",[e._v("注册表存储")]),e._v(" Docker 镜像。"),r("a",{attrs:{href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Hub"),r("OutboundLink")],1),e._v(" 是任何人都可以使用的公共注册表，并且默认情况下，Docker 已配置为在 "),r("a",{attrs:{href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Hub"),r("OutboundLink")],1),e._v(" 上查找镜像。您甚至可以运行自己的私人注册表。")]),e._v(" "),r("h3",{attrs:{id:"images"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#images"}},[e._v("#")]),e._v(" Images")]),e._v(" "),r("p",[e._v("Image "),r("mark",[e._v("镜像")]),e._v(" 是一个只读模板，带有创建 Docker 容器的说明。通常，一个镜像基于另一个镜像，并进行一些额外的定制。例如，您可以构建一个基于 "),r("code",[e._v("ubuntu")]),e._v(" 的镜像，然后安装 Apache web 服务器和您的应用程序，以及使应用程序运行所需的配置细节。")]),e._v(" "),r("p",[e._v("您可以创建自己的镜像，也可以只使用其他人创建并发布在注册表中的镜像。要构建自己的镜像，需要创建一个 "),r("RouterLink",{attrs:{to:"/pages/9a3b98/#Dockerfile"}},[e._v("Dockerfile")]),e._v("，该文件使用简单的语法来定义创建和运行镜像所需的步骤。"),r("RouterLink",{attrs:{to:"/pages/9a3b98/#Dockerfile"}},[e._v("Dockerfile")]),e._v(" 中的每条指令都会在镜像中创建一个层。当你改变 "),r("RouterLink",{attrs:{to:"/pages/9a3b98/#Dockerfile"}},[e._v("Dockerfile")]),e._v(" 并重建镜像时，只有那些已经改变的层才会被重建。与其他虚拟化技术相比，这是镜像如此轻量级、小巧和快速的部分原因。")],1),e._v(" "),r("h3",{attrs:{id:"containers"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#containers"}},[e._v("#")]),e._v(" Containers")]),e._v(" "),r("p",[e._v("Containers "),r("mark",[e._v("容器")]),e._v(" 是镜像的可运行实例。您可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。您可以将容器连接到一个或多个网络，将存储附加到其上，甚至可以根据其当前状态创建新镜像。")]),e._v(" "),r("p",[e._v("默认情况下，容器相对较好地与其他容器及其主机隔离。您可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。")]),e._v(" "),r("p",[e._v("容器是由它的"),r("code",[e._v("镜像")]),e._v("以及在创建或启动它时提供给它的任何"),r("code",[e._v("配置选项定义")]),e._v("的。当容器被"),r("code",[e._v("删除")]),e._v("时，"),r("code",[e._v("任何未存储在持久存储中的状态更改都会消失")]),e._v("。")]),e._v(" "),r("p",[r("code",[e._v("docker run")]),e._v(" 指令案例。下面的命令运行一个"),r("code",[e._v("ubuntu")]),e._v("容器，以交互方式连接到本地命令行会话，并运行"),r("code",[e._v("/bin/bash")])]),e._v(" "),r("div",{staticClass:"language-sh line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-sh"}},[r("code",[r("span",{pre:!0,attrs:{class:"token function"}},[e._v("docker")]),e._v(" run "),r("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-i")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-t")]),e._v(" ubuntu /bin/bash\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("p",[e._v("当您运行此命令时，会发生以下情况(假设您使用默认的注册表配置):")]),e._v(" "),r("ol",[r("li",[e._v("如果你在本地没有 "),r("code",[e._v("ubuntu")]),e._v(" 镜像，Docker 会从你配置的注册表中提取它，就像你手动运行 "),r("code",[e._v("docker pull ubuntu")]),e._v(" 一样。")]),e._v(" "),r("li",[e._v("Docker 创建一个新容器，就像您手动运行 "),r("code",[e._v("docker container create")]),e._v(" 命令一样。")]),e._v(" "),r("li",[e._v("Docker 为容器分配一个读写文件系统，作为它的最后一层。这允许运行中的容器在其本地文件系统中创建或修改文件和目录。")]),e._v(" "),r("li",[e._v("Docker 创建了一个网络接口，将容器连接到默认网络，因为您没有指定任何网络选项。这包括为容器分配一个 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。")]),e._v(" "),r("li",[e._v("Docker 启动容器并执行 "),r("code",[e._v("/bin/bash")]),e._v(" 由于容器以交互方式运行并连接到您的终端(由于 "),r("code",[e._v("-i")]),e._v(" 和 "),r("code",[e._v("-t")]),e._v(" 标志)，因此您可以使用键盘提供输入，同时将输出记录到您的终端。")]),e._v(" "),r("li",[e._v("当输入 "),r("code",[e._v("exit")]),e._v(" 终止 "),r("code",[e._v("/bin/bash")]),e._v(" 命令时，容器会停止，但不会被移除。您可以重新启动或删除它。")])]),e._v(" "),r("h2",{attrs:{id:"docker-底层技术"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#docker-底层技术"}},[e._v("#")]),e._v(" Docker 底层技术")]),e._v(" "),r("p",[e._v("Docker 是用 "),r("a",{attrs:{href:"https://go.dev/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go 编程语言"),r("OutboundLink")],1),e._v(" 编写的，并利用了 Linux 内核的几个特性来实现其功能。Docker 使用 "),r("code",[e._v("namespaces")]),e._v(" 的技术来提供容器的隔离工作空间。当你运行一个容器时，Docker 会为这个容器创建一组命名空间。")]),e._v(" "),r("p",[e._v("这些 "),r("code",[e._v("namespaces")]),e._v(" 提供了一层隔离。各个容器都在单独的 "),r("code",[e._v("namespaces")]),e._v(" 中运行，其访问仅限于该名称空间。")])])}),[],!1,null,null,null);r.default=a.exports}}]);